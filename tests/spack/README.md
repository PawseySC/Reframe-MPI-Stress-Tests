# Spack tests

This directory contains one test file, `spack_checks.py`. This file contains four separate tests, described in more detail below. Additionally, there is a file `spack_helper_methods.py` which defines functions used by the tests in processing the spack files and module names. Finally, there are two yaml files, a configuration file which defines system-level parameters and environment variables needed for the tests, plus one which holds the commands used for the `baseline_sanity_check` test. Details of how to configure the first yaml file are included at the end of this README. The `src` directory holds a minimal example of the `spack.yaml`, `spack.lock`, and `modules.yaml` files used in the tests.

## `spack_checks.py`

### `concretise_check`

This test checks the concretisation stage of `spack` by checking that for every abstract spec defined in a `spack.yaml` file, corresponding concretised spec(s) are defined in the `spack.lock` file. The test passes if every abstract spec is accounted for and fails if there is one or more missing concretised specs. This test is run once for every spack build environment

### `module_existence_check`

This test checks that for every package for whcih a module file is to be generated by `spack` that the module exists, as do all of the module files for its dependencies. This test is run once for every package which generates a module file.

### `module_load_check`

This test checks that for every package for which a module file is to be generated by `spack` that the module is able to be loaded without errors, failures, or warnings. The test also checks that every explicit load dependency (lines in the module file starting with `LOAD`) is loaded in the environment alongside the primary module. This test is run once for every package which generates a module file. There is a test dependency chain with this test and `module_existence_check`. For each package, this test only runs if `module_existence_check` passes for that package. If, however, the first test fails, this test will automatically fail as well.

### `baseline_sanity_check`

This test runs the most basic sanity check for each package. If the package is software the test executes a basic check of the binary via a command like `--help` or `--version`. If the test is a library, library dependencies are checked via the `ldd` command to check that all are present. This test is run once for every package and it forms a test dependency chain with the two previous tests. For each package this test only runs if both `module_existence_check` and `module_load_check` for the package have both passed. The commands run for each package are defined in the `pkg_cmds.yaml` file.


## Configuration for the tests

To run these tests over your own spack-installed sofrware stack, the `spack_config.yaml` file needs to be set properly. One also needs access to the `spack.yaml` and `spack.lock` file(s) used during concretisation and installation as well as `modules.yaml` file controlling spack module generation.

The setup steps required to run these tests are:

1. Configure the system-level parameters as done with other tests in this repo (`system` and `prog-environ`)
2. Set the `spack-setup` parameters which include the locations of files used by spack and the python version
    1. `spack-yaml-dir` is set differently depending on if your stack uses multple spack build environments or just one. If using just one build env, this parameter is set to the absolute path of the directory holding the `spack.yaml` file defining the abstract package specs. If using multiuple build environments this parameter is set to the absolute path of the directory where the environment directories (each of which holds their respective `spack.yaml` file) are located.
    2. `spack-lock-dir` is set the exact same as `spack-yaml-path` except it is referring to the `spack.lock` file holding the concretised package specs. This can be the same as `spack-yaml-dir` and indeed is on Setonix.
    3. `module-yaml-path` is the absolute path to the `modules.yaml` file.
3. Set the `software-path` parameters, which define the location where software are installed. Each parameter in this group refers to a different level of the directory hierarchy. For instance, on Setonix, a package is installed into `/software/setonix/${DATE_TAG}/software/${OS}-${ARCHITECTURE}/${COMPILER_NAME}-${COMPILER_VERSION}/{PACKAGE_NAME}-${PACKAGE_VERSION}-${PACKAGE_HASH}`. There will be 4 parameters in this group, one for the part of the path common to all packages, and the other three for package-specific parts. The values of these parameters are references to how to access package-specific values (e.g. package name, compiler name) from the package's concretised spec. For instance, a key-value pair of `compiler-name-version: {compiler,name}-{compiler,version}` means that for each package the name of that directory in the hierarchy is accessed from the concretised spec dictionary within python by `spec['compiler']['name'] + '-' + spec['compiler']['version']`.The default parameters, matching our software stack organisational hierarchy on Setonix, are
    1. `base-directory` is the part of the installation path common to every package (e.g. `/software/setonix/${DATE_TAG}/software`)
    2. `platform-os-arch` is the operating system and architecture (e.g. `linux-sles15-zen3`)
    3. `compiler-name-version` is the name and version of the compiler used for this package (e.g. `gcc-12.2.0`)
    4. `package-name-version-hash` is the package name, version, and unique hash (e.g. `python-3.10.10-al58hy0vc36`)
4. Set the `modules-path` parameters, which define the location where module files are located. Each parameter in this group refers to a different level of the directory hierarchy. The format of this is the same as for the `software-path` parameter group. Note that this only specifies the path up to the stage where the projections defined in `modules.yaml` begin. For instance, on Setonix, module files are located at `/software/setonix/${DATE_TAG}/modules/${ARCHITECTURE}/${COMPILER_NAME}/${COMPILER_VERSION}/${MODULE_CATEGORY}/${PACKAGE_NAME}/${PACKAGE_VERSION}.lua`. The `${MODULE_CATEGORY}/${PACKAGE_NAME}/${PACKAGE_VERSION}.lua` part for each package is defined in the projections of the `modules.yaml` file, so they are not part of this parameter group. The default parameters, matching our module paths on Setonix, are
    1. `base-directory` is the part of the installation path common to every package (e.g. `softwate/setonix/${DATE_TAG}/modules`)
    2. `architecture` is the architecture (e.g. `zen3`)
    3. `compiler-name` is the compiler name (e.g. `gcc`)
    4. `compiler-version` is the compiler version (e.g. `12.2.0`)

Once these are all set appropriately, the tests can be run over the software stack via the `run_spack_tests.sh` script.