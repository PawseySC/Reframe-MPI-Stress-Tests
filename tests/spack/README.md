# Spack tests

This directory contains one test file, `spack_checks.py`. This file contains four separate tests, described in more detail below. Additionally, there is a file `spack_helper_methods.py` which defines functions used by the tests in processing the spack files and module names. Finally, there are two yaml files, a configuration file which defines system-level parameters and environment variables needed for the tests, plus one which holds the commands used for the `baseline_sanity_check` test. Details of how to configure the first yaml file are included at the end of this README. The `src` directory holds a minimal example of the `spack.yaml`, `spack.lock`, and `modules.yaml` files used in the tests.

## `spack_checks.py`

### `concretise_check`

This test checks the concretisation stage of `spack` by checking that for every abstract spec defined in a `spack.yaml` file, corresponding concretised spec(s) are defined in the `spack.lock` file. The test passes if every abstract spec is accounted for and fails if there is one or more missing concretised specs. This test is run once for every spack build environment

### `module_existence_check`

This test checks that for every package for whcih a module file is to be generated by `spack` that the module exists, as do all of the module files for its dependencies. This test is run once for every package which generates a module file.

### `module_load_check`

This test checks that for every package for which a module file is to be generated by `spack` that the module is able to be loaded without errors, failures, or warnings. The test also checks that every explicit load dependency (lines in the module file starting with `LOAD`) is loaded in the environment alongside the primary module. This test is run once for every package which generates a module file. There is a test dependency chain with this test and `module_existence_check`. For each package, this test only runs if `module_existence_check` passes for that package. If, however, the first test fails, this test will automatically fail as well.

### `baseline_sanity_check`

This test runs the most basic sanity check for each package. If the package is software the test executes a basic check of the binary via a command like `--help` or `--version`. If the test is a library, library dependencies are checked via the `ldd` command to check that all are present. This test is run once for every package and it forms a test dependency chain with the two previous tests. For each package this test only runs if both `module_existence_check` and `module_load_check` for the package have both passed. The commands run for each package are defined in the `pkg_cmds.yaml` file.


## Configuration for the tests

To run these tests over your own spack-installed sofrware stack, the `spack_config.yaml` file needs to be set properly. One also needs access to the `spack.yaml` and `spack.lock` file(s) used during concretisation and installation as well as `modules.yaml` file controlling spack module generation.

The setup steps required to run these tests are:

1. Configure the system-level parameters as done with other tests in this repo (`system` and `prog-environ`)
2. Set the `spack-setup` parameters which include the locations of files used by spack and the python version
    1. `spack-yaml-dir` is set differently depending on if your stack uses multple spack build environments or just one. If using just one build env, this parameter is set to the absolute path of the directory holding the `spack.yaml` file defining the abstract package specs. If using multiuple build environments this parameter is set to the absolute path of the directory where the environment directories (each of which holds their respective `spack.yaml` file) are located.
    2. `spack-lock-dir` is set the exact same as `spack-yaml-path` except it is referring to the `spack.lock` file holding the concretised package specs. This can be the same as `spack-yaml-dir` and indeed is on Setonix.
    3. `module-yaml-path` is the absolute path to the `modules.yaml` file.
3. Set the `software-path` parameters, which define the location where software are installed. This assumes packages are installed into a directory of the form `/{BASE_PATH}/{PKG_SPECIFIC_PATH}`, where `${BASE_PATH}` is common to all packages and `${PKG_SPECIFIC_PATH}` consists of a directory hierarchy unique to each package. In this case one of the parameters is just the base path. The other parameters are each directory in the package specific path and how to set them from the package's concretised spec. Examples specific to our Setonix setup are included in the `spack_config.yaml` file.
4. Set the `modules-path` parameters, which define the location where module files are located. This assumes modules files are located in a directory of the form `/${BASE_PATH}/{PKG_SPECIFIC_PATH}/${PROJECTIONS}`, where `${BASE_PATH` is common to all packages and `${PKG_SPECIFIC_PATH` consists of a directory hierarchy unique to each package, and `${PROJECTIONS}` are defined in the `modules.yaml` file. In this case one of the parameters is just the bash path. The other parametes are each directory in the package specific path and how to set them from the package's concretised spec. Examples specific to our Setonix setup are included in the `spack_config.yaml` file.

Once these are all set appropriately, the tests can be run over the software stack via the `run_spack_tests.sh` script.
